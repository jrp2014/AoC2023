{-# LANGUAGE ParallelListComp #-}

-- The following uses code from the polynomial package:
-- https://hackage.haskell.org/package/polynomial-0.7.3/docs/Math-Polynomial-Interpolation.html
-- The code is more general than needed to solve these puzzles as it doesn't assume that the points
-- are a fixed distance apart.  (This means that it we need to use rationals, rather Ints.
-- Anyway, divided differences

module Day09 where

import Data.List (tails)

-- | Evaluate a polynomial passing through the specified set of points.  The
--  order of the interpolating polynomial will (at most) be one less than
--  the number of points given.
polyInterp :: (Fractional a) => [(a, a)] -> a -> a
polyInterp xys = head . last . neville xys

-- | Computes the tableau generated by Neville's algorithm.  Each successive
--  row of the table is a list of interpolants one order higher than the previous,
--  using a range of input points starting at the same position in the input
--  list as the interpolant's position in the output list.
neville :: (Fractional a) => [(a, a)] -> a -> [[a]]
neville xys x = table
  where
    (xs, ys) = unzip xys
    table =
      ys
        : [ [ ((x - x_j) * p1 + (x_i - x) * p0) / (x_i - x_j)
              | p0 : p1 : _ <- tails row
              | x_j <- xs
              | x_i <- x_is
            ]
            | row <- table
            | x_is <- tail (tails xs),
              not (null x_is)
          ]

-- | Computes the tableau generated by a modified form of Neville's algorithm
--  described in Numerical Recipes, Ch. 3, Sec. 2, which records the differences
--  between interpolants at each level.  Each pair (c,d) is the amount to add
--  to the previous level's interpolant at either the same or the subsequent
--  position (respectively) in order to obtain the new level's interpolant.
--  Mathematically, either sum yields the same value, but due to numerical
--  errors they may differ slightly, and some \"paths\" through the table
--  may yield more accurate final results than others.
nevilleDiffs :: (Fractional a) => [(a, a)] -> a -> [[(a, a)]]
nevilleDiffs xys x = table
  where
    (xs, ys) = unzip xys
    table =
      zip ys ys
        : [ [ (
                {-c-} (x_j - x) * (c1 - d0) / (x_j - x_i),
                {-d-} (x_i - x) * (c1 - d0) / (x_j - x_i)
              )
              | (_c0, d0) : (c1, _d1) : _ <- tails row
              | x_j <- xs
              | x_i <- x_is
            ]
            | row <- table
            | x_is <- tail (tails xs),
              not (null x_is)
          ]

part1 :: [(Rational, Rational)] -> Rational
part1 xys = polyInterp xys (toRational (1 + length xys))

part2 :: [(Rational, Rational)] -> Rational
part2 xys = polyInterp xys 0

main :: IO ()
main = do
  input <- readFile "input.txt"
  let pinput =
        zip (map (toRational @Int) [1 ..])
          . (map (toRational . read @Int) . words)
          <$> lines input

  print $ sum $ map part1 pinput
  print $ sum $ map part2 pinput
